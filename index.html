<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <!-- 預載入字體 CSS 文件 -->
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=block" as="style">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=UoqMunThenKhung&display=block" as="style">
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=Diphylleia&display=block" as="style">

    <!-- 載入字體 CSS -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=block" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=UoqMunThenKhung&display=block" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Diphylleia&display=block" rel="stylesheet">
    
    <title>Fortune Seeker✨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .loading-text,
        .blessing-message,
        .blessing-name {
            min-height: 2em;
            min-width: 300px;
        }

        body {
            font-family: 'ZCOOL KuaiLe', "UoqMunThenKhung", "Diphylleia", sans-serif;
            background-image: url("bgimage.jpeg");
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none; /* 禁止手機滑動頁面 */
        }

        /* --- 載入頁面 --- */
        .loading-page {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .loading-text {
            top: 10%;
            position: absolute;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
            color: #e0f8ff;
            font-weight: bold;
            text-shadow: 2px 2px 4px #e0f8ff;
            animation: twinkle 1.8s ease infinite;
            animation-delay: 3s;
            pointer-events: none;
            z-index: 10;
        }

        /* --- 星星與 Canvas --- */
        .Stars {
            position: relative;
            width: 450px;
            height: 100vh;
        }

        #lineCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: auto; /* 接收滑動事件 */
        }

        .star {
            transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;
            pointer-events: none; /* 保持 none，讓 Canvas 處理邏輯，游標由 JS 控制 */
            opacity: 0.4; 
            position: absolute;
        }

        /* 1. 當輪到這顆星星時的提示樣式 (呼吸燈效果) */
        .star.next-target {
            opacity: 1;
            animation: pulse-guide 1.5s infinite ease-in-out;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.6));
        }

        /* 2. 當游標靠近這顆星星時的反應 (Hover 效果) */
        .star.hovering {
            transform: scale(1.3);
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 1));
        }

        /* 已經連線選中後的樣式 (保持亮起) */
        .star.active {
            opacity: 1;
            transform: scale(1.2);
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.9));
            animation: none; /* 停止呼吸動畫 */
        }

        @keyframes pulse-guide {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.15); opacity: 1; filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8)); }
            100% { transform: scale(1); opacity: 0.8; }
        }

        /* 星星位置調整 (保持您前一次要求的等比拉遠) */
        #Star1 { top: 25%; left: 64%; animation: FadeIn 1s ease-in-out; }
        #Star2 { top: 60%; left: 24%; }
        #Star3 { top: 50%; left: 58%; }
        #Star4 { top: 37%; left: 22%; }
        #Star5 { top: 70%; left: 61%; }

        /* --- 原始 CSS --- */
        .blessing-name, .link {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
            color: #e0f8ff;
            font-weight: bold;
            text-shadow: 2px 2px 4px #e0f8ff;
            animation-delay: 3s;
            text-decoration: none;
        }
        .blessing-name { padding-bottom: 10vh; }
        .link { animation: twinkle 3s ease infinite; animation-delay: 10s; }
        .link:hover { cursor: pointer; color: #ffffff; text-shadow: 2px 2px 5px #ffffff; }
        .song-today { height: auto; padding-top: 10vh; padding-bottom: 1vh; }
        @keyframes twinkle { 40% { opacity: 0.2; } 70% { opacity: 1; } }

        #whiteOverlay {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background-color: white;
            opacity: 0;
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            pointer-events: none;
            transition: transform 1.5s ease-out, opacity 1s ease-out;
            z-index: 9999;
            box-shadow: 0 0 100px 50px white;
        }
        #blackOverlay {
            position: fixed;
            width: 100vw;
            height: 100vh;
            background-color: rgb(255, 255, 255);
            opacity: 1;
            pointer-events: none;
            transition: opacity 3s ease-out;
            z-index: 9999;
        }
        .result-page {
            border: #f208b4 0px solid;
            position: fixed;
            display: flex;
            flex-direction: column;
            text-align: center;
            justify-content: center;
            align-items: center;
            max-width: 500px;
            width: 100%;
            padding-top: 250px;
            height: 100vh;
            border-radius: 25px;
        }
        .container {
            width: auto;
            top: -200px;
            position: relative;
            border: #0822f2 0px solid;
            display: flex;
            flex-direction: column;
            height: 60vh;
        }
        .opacity0 { opacity: 0; transition: opacity 1s ease-in-out; }
        .blessing-message {
            width: 100%;
            text-align: center;
            font-family: "Diphylleia", sans-serif;
            color: #e0f8ff;
            font-weight: bold;
            text-shadow: 2px 2px 5px #69a0cd;
            font-size: 1.6rem;
            line-height: 1.3;
            margin-bottom: 20px;
            font-weight: 500;
            transition: transform 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 1s ease-out;
        }
        .blessing-message-trans {
            width: 100%;
            text-align: center;
            font-family: "Diphylleia", "UoqMunThenKhung", sans-serif;
            color: #e0f8ff;
            text-shadow: 2px 2px 5px #69a0cd;
            font-size: 0.8rem;
            line-height: 1.3;
            margin-bottom: 5px;
            font-weight: 500;
            transition: transform 1.8s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 1s ease-out;
        }
        .blessing-message.move-up { transform: translateY(-200px) scale(0.8); }
        .result-page.show { display: block; animation: slideIn 0.5s ease; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes FadeIn { from { opacity: 0; } to { opacity: 1; } }
        .site-footer { bottom: 5%; text-align: center; font-size: 0.5rem; font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif; color: #777; margin-top: 10px; }
        .hidden { display: none !important; }
    </style>
</head>

<body>

    <div class="loading-page" id="loadingPage">
        <div class="loading-text">
            <span id="loadingText" class="hidden">Draw the star to connect.</span>
        </div>
        
        <div class="Stars" id="AllStars">
            <canvas id="lineCanvas"></canvas>
            <img class="star visible" src="circle3.png" id="Star1" style="width: 10%; height: auto;">
            <img class="star visible" src="circle3.png" id="Star2" style="width: 10%; height: auto;">
            <img class="star visible" src="circle3.png" id="Star3" style="width: 10%; height: auto;">
            <img class="star visible" src="circle3.png" id="Star4" style="width: 10%; height: auto;">
            <img class="star visible" src="circle3.png" id="Star5" style="width: 10%; height: auto;">
        </div>
    </div>
    
    <div id="blackOverlay"></div>
    <div id="whiteOverlay"></div>

    <div class="result-page hidden" id="resultPage">
        <div class="blessing-message" id="blessingMessage"></div>
        <div class="container" id="container">
            <div class="blessing-message-trans opacity0" id="blessingName1"></div><br>
            <div class="blessing-message-trans opacity0" id="blessingName2"></div>
            <div class="blessing-name opacity0" id="blessingName"></div>
            <a class="link opacity0" id="link" href="https://youtu.be/IcwHopeT5gY?si=M2At0eYrsLjppR3M" style="font-size: 0.9rem;">
                Finally, <br>we'll meet together here...
            </a>
            <div style="display:flex; justify-content: center; align-items: center; width: 100%;">
                <iframe class="song-today opacity0" id="songToday" style="border-radius:12px;" src="" width="100%" height="100" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>
            </div>
            <div class="site-footer opacity0" id="siteFooter">
                <p>Site by @yingssin_ <br>Non-commercial use | With ChatGPT Claude.ai Gemini support</p>
            </div>
        </div>
    </div>

    <script>
        const members = ['Soobin', 'Yeonjun', 'Beomgyu', 'Taehyun', 'Hueningkai'];
        const blessingNames = ['- SOOBIN -', '- YEONJUN -', '- BEOMGYU -', '- TAEHYUN -', '- HUENINGKAI -'];
        let currentLanguage = 'en';

        const messages = {
            tw: {
                'Soobin': ["努力不一定會馬上獲得回報，但總有一天會以某種方式回到你身邊", "今天的你已經很努力了，我們繼續充滿活力的生活下去吧", "所有的傷口都會隨著時間過去而逐漸淡去"],
                'Yeonjun': ["雖然是些微不足道的小事，但一點一滴累積就會變得壯觀", "那些讓人恐懼並想逃避的，正是我們必須面對的道路", "往「最好」的方向走，最終你會成為那個獨一無二的人"],
                'Beomgyu': ["痛苦過後，幸福會來臨的", "鼓起勇氣試一次看看吧", "為了想做的事，有些東西是需要放棄的"],
                'Taehyun': ["堅韌固然很好，但有時候也需要柔軟才能不被折斷", "承擔責任，但不要感到負擔", "即使烏雲密布，雲後的天空依然是湛藍的"],
                'Hueningkai': ["忙碌地生活很好，但心靈的餘裕是絕對必要的", "彼此的信任感越深，團隊就會變得更加堅固", "不要成為一個不幸的人"]
            },
            kr: {
                'Soobin': ["노력의 보상이 지금 당장 보이지 않더라도, 언젠가 어떤 길로든 결국은 돌아올 겁니다", "오늘도 고생 많았어요 힘차게 살아가요", "모든 상처들은 시간이 지나면 무뎌지기 마련인데"],
                'Yeonjun': ["사소한 거지만 그런 하나하나가 모이면 크니까요", "두렵고 피하고 싶은 대상이 곧 내가 마주해야 할 길이다", "best로 가다보면 유일한 사람이 되어있을거고"],
                'Beomgyu': ["아픔 뒤에 행복이 오겠구나", "용기를 갖고 한번 부딪혀 보세요", "하고 싶은 걸 하기 위해서는 포기해야 하는 것도 있어요"],
                'Taehyun': ["굳건함도 좋지만 가끔은 부러지지 않기 위한 유연함을", "책임감을 갖되, 부담감만 내려놔야 돼요", "구름이 껴도 그 뒤의 하늘은 푸른색이죠"],
                'Hueningkai': ["바쁘게 사는것도 좋지만 마음의 여유도 꼭 필요해요", "서로의 신뢰가 커질수록 팀이 더 단단해지니까요", "불행한 사람이 되지 말자"]
            },
            en: {
                'Soobin': ["Efforts may not be rewarded immediately but eventually return in some way.", "You worked hard today. <br>Let's continue to live vibrantly.", "All wounds naturally become less painful."],
                'Yeonjun': ["They might be minor things, but each adds up to something big.", "What we fear and wanna avoid is precisely the path we must face.", "If you strive for the best, you'll find yourself becoming unique."],
                'Beomgyu': ["Happiness will come after the pain.", "Take courage and give it a try.", "To do what you want, <br>there are also things you have to give up."],
                'Taehyun': ["Strength is good, but sometimes need flexibility not to break.", "Have a sense of responsibility, <br>but let go of the burden.", "Even if it's cloudy, <br>the sky behind it is still blue."],
                'Hueningkai': ["It's good to live busy, but mental space is also essential.", "As mutual trust grows, <br>the team becomes stronger.", "Let's not become an unhappy person."]
            }
        };

        const songs = {
            'Soobin': ["https://open.spotify.com/embed/track/4QfHWIOU5nh4yBdYSnt1AE?utm_source=generator&theme=0&transparent=true"],
            'Yeonjun': ["https://open.spotify.com/embed/track/5voKDnuTGXBnIZbAqWnb8R?utm_source=generator&theme=0&transparent=true"],
            'Beomgyu': ["https://open.spotify.com/embed/track/13tz8REkfaAuQrmKQwbToR?utm_source=generator&theme=0&transparent=true"],
            'Taehyun': ["https://open.spotify.com/embed/track/73TsDyUBDWG2KnCZuLM7KB?utm_source=generator&theme=0&transparent=true"],
            'Hueningkai': ["https://open.spotify.com/embed/track/7a9q19sVTEAq0SzgUZvbSy?utm_source=generator&theme=0&transparent=true"],
            'All': ["https://open.spotify.com/embed/track/6bp3UWuLklGIK8VgkRUKkP?utm_source=generator&theme=0&transparent=true", "https://open.spotify.com/embed/track/6IYvOX6K6tbBmj00JRU5Rw?utm_source=generator&theme=0&transparent=true", "https://open.spotify.com/embed/track/1Kv0G4eKjJ4ysGRXlHvQCm?utm_source=generator&theme=0&transparent=true"]
        };

        function detectSystemLanguage() {
            const userLang = navigator.language || navigator.userLanguage;
            if (userLang.startsWith('ko')) return 'kr';
            if (userLang.startsWith('tw') || userLang.startsWith('zh')) return 'tw';
            return 'en';
        }

        function OpacityTo1(elementID) {
            const el = document.getElementById(elementID);
            if (el) el.style.opacity = '1';
        }
        
        function RemoveHidden(elementID) {
            const el = document.getElementById(elementID);
            if (el) el.classList.remove('hidden');
        }

        // --- 遊戲邏輯 ---
        // 1. 修改順序：移除最後一個回到1的步驟
        const CORRECT_SEQUENCE = [1, 2, 3, 4, 5]; 
        const canvas = document.getElementById('lineCanvas');
        const ctx = canvas.getContext('2d');
        const starsContainer = document.getElementById('AllStars');
        const starElements = [1, 2, 3, 4, 5].map(i => document.getElementById(`Star${i}`));
        
        let width, height;
        let currentSequenceIndex = 0;
        let isDragging = false;
        let currentPos = { x: 0, y: 0 };
        let isGameWon = false;
        let pathPoints = []; 

        function resize() {
            const rect = starsContainer.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
            canvas.width = width;
            canvas.height = height;
            if(!isGameWon) render();
        }

        function updateStarVisuals() {
            if(isGameWon) return;
            const targetStarID = CORRECT_SEQUENCE[currentSequenceIndex];
            
            starElements.forEach((el, index) => {
                if ((index + 1) === targetStarID) {
                    el.classList.add('next-target');
                } else {
                    el.classList.remove('next-target');
                }
            });
        }

        function render() {
            ctx.clearRect(0, 0, width, height);

            if (pathPoints.length === 0 && !isDragging) return;

            // 1. 畫起始的細線 (如果有)
            // 只有當 pathPoints 至少有 2 個點 (虛擬點 + 第一顆星) 時才畫這條特殊的線
            if (pathPoints.length >= 2) {
                ctx.beginPath();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                // 設定細一點、淡一點的樣式
                ctx.lineWidth = 1; 
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; 
                ctx.shadowBlur = 0; 

                ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                ctx.lineTo(pathPoints[1].x, pathPoints[1].y);
                ctx.stroke();
            }

            // 2. 畫玩家連線的粗線 (從第一顆星開始往後)
            ctx.beginPath();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 3; 
            // 主線透明度 0.4
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';

            let hasMainLine = false;

            // 如果已經連了超過一顆星 (例如 P0, P1, P2...)
            if (pathPoints.length > 1) {
                // 移動到第一顆星的位置 (P1)
                ctx.moveTo(pathPoints[1].x, pathPoints[1].y);
                
                // 畫剩下的路徑
                for (let i = 2; i < pathPoints.length; i++) {
                    ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                }
                hasMainLine = true;
            }

            // 處理拖曳線
            if (isDragging) {
                if (pathPoints.length > 0) {
                    const lastPoint = pathPoints[pathPoints.length - 1];
                    // 如果還沒 moveTo 過，需要先 moveTo
                    if (!hasMainLine) {
                        ctx.moveTo(lastPoint.x, lastPoint.y);
                    }
                    ctx.lineTo(currentPos.x, currentPos.y);
                    hasMainLine = true;
                }
            }

            if (hasMainLine) {
                ctx.stroke();
            }
            
            ctx.shadowBlur = 0;
        }

        function getStarCenter(index) {
            const el = starElements[index]; 
            const starRect = el.getBoundingClientRect();
            const containerRect = starsContainer.getBoundingClientRect();
            return {
                x: (starRect.left - containerRect.left) + starRect.width / 2,
                y: (starRect.top - containerRect.top) + starRect.height / 2
            };
        }

        // 2. 計算真正的幾何中心（透過兩條線的交點）
        // 線段1: 上(Star1) -> 左下(Star2)
        // 線段2: 左上(Star4) -> 右(Star3)
        function getTrueCenterIntersection() {
            const s1 = getStarCenter(0); // Star 1
            const s2 = getStarCenter(1); // Star 2
            
            const s4 = getStarCenter(3); // Star 4
            const s3 = getStarCenter(2); // Star 3
            
            return getIntersection(s1, s2, s4, s3);
        }

        // 線段交點計算公式
        function getIntersection(A, B, C, D) {
            const a1 = B.y - A.y;
            const b1 = A.x - B.x;
            const c1 = a1 * A.x + b1 * A.y;
            
            const a2 = D.y - C.y;
            const b2 = C.x - D.x;
            const c2 = a2 * C.x + b2 * C.y;
            
            const determinant = a1 * b2 - a2 * b1;
            
            if (determinant === 0) {
                return { x: 0, y: 0 };
            } else {
                return {
                    x: (b2 * c1 - b1 * c2) / determinant,
                    y: (a1 * c2 - a2 * c1) / determinant
                };
            }
        }

        // 計算起始的虛擬點 (從交點連向 Star3 的 40% 處)
        function getPhantomCenter() {
            const trueCenter = getTrueCenterIntersection();
            const star3 = getStarCenter(2); // Star 3 (Right)
            
            // 向量：從中心指向 Star3 (Right)
            const vecX = star3.x - trueCenter.x;
            const vecY = star3.y - trueCenter.y;
            
            // 取 40% 的位置 (4:6 靠近中心)
            return {
                x: trueCenter.x + vecX * 0.4,
                y: trueCenter.y + vecY * 0.4
            };
        }

        function checkCollision(pos) {
            const targetStarID = CORRECT_SEQUENCE[currentSequenceIndex];
            const targetIndex = targetStarID - 1; 
            const el = starElements[targetIndex];
            
            const center = getStarCenter(targetIndex);
            const dist = Math.hypot(pos.x - center.x, pos.y - center.y);
            
            if (dist < 40) { 
                // 如果是第一顆星，先加入計算好的虛擬起點
                if (currentSequenceIndex === 0) {
                    pathPoints.push(getPhantomCenter());
                }

                pathPoints.push(center);
                el.classList.add('active');
                el.classList.remove('next-target');
                el.classList.remove('hovering');
                if (navigator.vibrate) navigator.vibrate(10);
                
                currentSequenceIndex++;
                updateStarVisuals();
                
                if (currentSequenceIndex >= CORRECT_SEQUENCE.length) {
                    finishGame();
                }
            }
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function onStart(e) {
            if (isGameWon) return;
            
            if (currentSequenceIndex === 0) {
                const startPos = getPos(e);
                const startID = CORRECT_SEQUENCE[0];
                const center = getStarCenter(startID - 1);
                const dist = Math.hypot(startPos.x - center.x, startPos.y - center.y);
                
                if (dist < 40) {
                    isDragging = true;
                    currentPos = startPos;
                    checkCollision(startPos);
                    render();
                }
            } else {
                isDragging = true;
            }
        }

        function onMove(e) {
            if (!isDragging && isGameWon) return;
            e.preventDefault();
            currentPos = getPos(e);
            
            const targetStarID = CORRECT_SEQUENCE[currentSequenceIndex];
            const targetIndex = targetStarID - 1;
            const el = starElements[targetIndex];
            const center = getStarCenter(targetIndex);
            const dist = Math.hypot(currentPos.x - center.x, currentPos.y - center.y);
            
            if (dist < 60) {
                el.classList.add('hovering');
                document.body.style.cursor = 'pointer'; 
            } else {
                el.classList.remove('hovering');
                document.body.style.cursor = 'default';
            }

            if (isDragging) {
                checkCollision(currentPos);
                render();
            }
        }

        function onEnd(e) {
            if (isGameWon) return;
            isDragging = false;
            currentSequenceIndex = 0;
            pathPoints = [];
            starElements.forEach(el => {
                el.classList.remove('active');
                el.classList.remove('hovering');
            });
            updateStarVisuals();
            render();
            document.body.style.cursor = 'default'; 
        }

        function finishGame() {
            isGameWon = true;
            isDragging = false;
            document.body.style.cursor = 'default'; 

            canvas.style.transition = 'opacity 0.5s';
            canvas.style.opacity = '0';
            
            starElements.forEach(el => {
                el.classList.remove('next-target');
                el.classList.remove('hovering');
            });

            const containerRect = starsContainer.getBoundingClientRect();
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            
            setTimeout(() => {
                starElements.forEach((el, i) => {
                    const starRect = el.getBoundingClientRect();
                    const starX = (starRect.left - containerRect.left) + starRect.width / 2;
                    const starY = (starRect.top - containerRect.top) + starRect.height / 2;
                    
                    const dx = centerX - starX;
                    const dy = centerY - starY;
                    
                    el.style.transition = 'transform 1s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                    el.style.transform = `translate(${dx}px, ${dy}px) rotate(720deg) scale(0.6)`;
                    el.style.opacity = '1'; 
                });
            }, 500);

            setTimeout(() => {
                starElements.forEach(el => {
                    el.style.transition = 'opacity 0.5s ease';
                    el.style.opacity = '0';
                });
            }, 1500);

            setTimeout(() => {
                const overlay = document.getElementById('whiteOverlay');
                overlay.style.width = '300vw';
                overlay.style.height = '300vw';
                overlay.style.opacity = '1';
                overlay.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 2000); 

            setTimeout(() => {
                showResult();
                const overlay = document.getElementById('whiteOverlay');
                overlay.style.opacity = '0';
                document.getElementById('blackOverlay').style.opacity = '0';
            }, 3500);
        }

        function showResult() {
            const loadingPage = document.getElementById('loadingPage');
            const resultPage = document.getElementById('resultPage');
            
            const randomMemberIndex = Math.floor(Math.random() * members.length);
            const randomMember = members[randomMemberIndex];
            const randomName = blessingNames[randomMemberIndex];
            
            const randomMessageIndex = Math.floor(Math.random() * messages['en'][randomMember].length);
            const randomMessageEn = messages['en'][randomMember][randomMessageIndex];
            const randomMessageKr = messages['kr'][randomMember][randomMessageIndex] || "";
            const randomMessageTw = messages['tw'][randomMember][randomMessageIndex] || "";

            const randomSong = songs[randomMember][0];
            const randomSongA = songs['All'][Math.floor(Math.random() * 3)];
            const randomSongFinal = Math.random() < 0.5 ? randomSong : randomSongA;

            document.getElementById('blessingMessage').innerHTML = randomMessageEn;
            document.getElementById('blessingName1').innerHTML = randomMessageTw;
            document.getElementById('blessingName2').innerHTML = randomMessageKr;
            document.getElementById('blessingName').innerHTML = "<br>" + randomName;
            document.getElementById('songToday').src = randomSongFinal;

            loadingPage.classList.add('hidden');
            resultPage.classList.remove('hidden');

            setTimeout(() => {
                document.getElementById('blessingMessage').classList.add('move-up');
            }, 4000);

            setTimeout(() => {
                OpacityTo1("songToday");
                OpacityTo1("blessingName");
                OpacityTo1("blessingName1");
                OpacityTo1("blessingName2");
                OpacityTo1("link");
                OpacityTo1("siteFooter");
            }, 5000);
        }

        function initializePage() {
            const overlayB = document.getElementById('blackOverlay');
            overlayB.style.opacity = '0';
            setTimeout(() => { RemoveHidden("loadingText"); }, 100);
            resize();
            updateStarVisuals(); // 初始化第一顆星的提示
        }

        window.addEventListener('resize', resize);
        
        canvas.addEventListener('mousedown', onStart);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onEnd);
        
        canvas.addEventListener('touchstart', onStart, { passive: false });
        window.addEventListener('touchmove', onMove, { passive: false });
        window.addEventListener('touchend', onEnd);

        window.addEventListener('DOMContentLoaded', initializePage);

    </script>
</body>
</html>
